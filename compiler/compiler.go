package compiler

import (
	_ "embed"
	"fmt"
	"gqlc/config"
	"gqlc/parser"
	"gqlc/schema"
	"io"
	"os"
	"path"
	"strings"
	"sync"
)

var (
	//go:embed runtime.ts
	TypeScriptRuntime string
)

const placeholder = "\n  // GQLC_OPERATIONS_PLACEHOLDER"

func Compile(cfg config.Config, operationsSrc []*os.File, genSchemaCode io.Writer, genSchemaName string, genOperationCode io.Writer) error {
	if _, err := fmt.Fprint(genSchemaCode, "// Generated by gqlc\n\n"); err != nil {
		return fmt.Errorf("failed to write generated header to output: %w", err)
	}
	if _, err := fmt.Fprint(genOperationCode, "// Generated by gqlc\n\n"); err != nil {
		return fmt.Errorf("failed to write generated header to output: %w", err)
	}

	operations := make(chan parser.AST)
	if len(operationsSrc) == 0 {
		close(operations)
	} else {
		var wg sync.WaitGroup
		for _, src := range operationsSrc {
			wg.Add(1)
			go func(src *os.File) {
				defer wg.Done()
				for ast := range parser.Parse(src) {
					operations <- ast
				}
			}(src)
		}

		go func() {
			wg.Wait()
			close(operations)
		}()
	}

	sch, err := schema.Load(cfg)
	if err != nil {
		return fmt.Errorf("failed to load schema: %w", err)
	}

	switch strings.ToLower(cfg.Output.Language) {
	case "typescript", "ts", "typescriptreact", "tsx":
		// Remove .ts extension for TypeScript imports
		schemaPath := "./" + genSchemaName
		schemaPath = strings.TrimSuffix(schemaPath, path.Ext(schemaPath))

		// Write import and runtime with placeholder
		runtimeWithPlaceholder := TypeScriptRuntime
		placeholderIndex := strings.Index(runtimeWithPlaceholder, placeholder)
		if placeholderIndex == -1 {
			return fmt.Errorf("runtime template missing %s", strings.TrimSpace(placeholder))
		}

		// Write everything before the placeholder
		if _, err := fmt.Fprintf(genOperationCode, "import * as schema from %q;\n\n", schemaPath); err != nil {
			return fmt.Errorf("failed to write import statement to output: %w", err)
		}
		if _, err := fmt.Fprint(genOperationCode, runtimeWithPlaceholder[:placeholderIndex]); err != nil {
			return fmt.Errorf("failed to write runtime before placeholder: %w", err)
		}

		// Collect operations and generate methods directly to the writer
		var collectedOperations []parser.AST

		for opAst := range operations {
			collectedOperations = append(collectedOperations, opAst)
			if _, err := opAst.GenerateTypeScriptMethod(genOperationCode); err != nil {
				return fmt.Errorf("failed to generate TypeScript operation method: %w", err)
			}
		}

		// Write everything after the placeholder
		if _, err := fmt.Fprint(genOperationCode, runtimeWithPlaceholder[placeholderIndex+len(placeholder):]); err != nil {
			return fmt.Errorf("failed to write runtime after placeholder: %w", err)
		}

		if err := sch.GenerateTypeScriptWithOperations(nil, collectedOperations, genSchemaCode); err != nil {
			return fmt.Errorf("failed to write TypeScript schema to output: %w", err)
		}
	default:
		return fmt.Errorf("unsupported language: %s", cfg.Output.Language)
	}

	return nil
}
